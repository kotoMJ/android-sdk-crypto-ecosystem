name: CI Pipeline

# When this action should run
on:
  # Run on pushes to the 'main' branch
  push:
    branches: [ "main" ]

  # Run on ALL pull requests
  pull_request:

jobs:
  build:
    name: CodeGuard
    runs-on: ubuntu-latest

    env:
      CRYPTO_SDK_NEWS_API_KEY: ${{ secrets.CRYPTO_SDK_NEWS_API_KEY }}

    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # This tells the action to get all history and tags

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'gradle' # Caches Gradle dependencies for faster builds

      - name: Make gradlew executable
        run: chmod +x ./gradlew

      # REQUIRED: Enable KVM for hardware acceleration
      # Without this, GMD will fail or be extremely slow

      - name: Enable KVM group perms
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm

      # --- STEP 1: SPOTLESS ---
      - name: Check Spotless
        id: spotless
        continue-on-error: true  # Allows pipeline to continue even if this fails
        run: ./gradlew spotlessCheck

      - name: Badge Spotless
        uses: schneegans/dynamic-badges-action@v1.7.0
        with:
          auth: ${{ secrets.BADGE_GIST_TOKEN }}
          gistID: ${{ secrets.BADGE_GIST_ID }}
          filename: badge-spotless.json
          label: Spotless
          message: ${{ steps.spotless.outcome }}
          color: ${{ steps.spotless.outcome == 'success' && 'success' || 'critical' }}

      # --- STEP 2: DETEKT ---
      - name: Check Detekt
        id: detekt
        continue-on-error: true
        run: ./gradlew detekt

      - name: Badge Detekt
        uses: schneegans/dynamic-badges-action@v1.7.0
        with:
          auth: ${{ secrets.BADGE_GIST_TOKEN }}
          gistID: ${{ secrets.BADGE_GIST_ID }}
          filename: badge-detekt.json
          label: Detekt
          message: ${{ steps.detekt.outcome }}
          color: ${{ steps.detekt.outcome == 'success' && 'success' || 'critical' }}

      # --- STEP 3: MODULE VERSIONS ---
      - name: Check Module Versions
        id: versions
        continue-on-error: true
        run: ./gradlew checkModuleVersions

      - name: Badge Module Versions
        uses: schneegans/dynamic-badges-action@v1.7.0
        with:
          auth: ${{ secrets.BADGE_GIST_TOKEN }}
          gistID: ${{ secrets.BADGE_GIST_ID }}
          filename: badge-module-versions.json
          label: Unit Tests
          message: ${{ steps.versions.outcome }}
          color: ${{ steps.versions.outcome == 'success' && 'success' || 'critical' }}

      # --- STEP 4: UNIT TESTS ---
      - name: Check Unit Tests
        id: unit
        continue-on-error: true
        run: ./gradlew testDebug

      - name: Badge Unit Tests
        uses: schneegans/dynamic-badges-action@v1.7.0
        with:
          auth: ${{ secrets.BADGE_GIST_TOKEN }}
          gistID: ${{ secrets.BADGE_GIST_ID }}
          filename: badge-tests-unit.json
          label: Unit Tests
          message: ${{ steps.unit.outcome }}
          color: ${{ steps.unit.outcome == 'success' && 'success' || 'critical' }}

      # --- STEP 5: INSTRUMENTED TESTS ---
      - name: Check Managed Device Tests
        id: instr
        continue-on-error: true
        env:
          GRADLE_OPTS: "-Dorg.gradle.jvmargs=-Xmx2g -Dkotlin.daemon.jvm.options=-Xmx2g"
        run: ./gradlew pixel4api35aospatdCheck

      - name: Badge Instrumented
        uses: schneegans/dynamic-badges-action@v1.7.0
        with:
          auth: ${{ secrets.BADGE_GIST_TOKEN }}
          gistID: ${{ secrets.BADGE_GIST_ID }}
          filename: badge-tests-instr.json
          label: Instrumented
          message: ${{ steps.instr.outcome }}
          color: ${{ steps.instr.outcome == 'success' && 'success' || 'critical' }}

      # --- FINAL CHECK ---
      # Because we used 'continue-on-error', the job thinks it succeeded.
      # We must manually check if any step failed and break the build if so.
      - name: Check Final Status
        if: steps.spotless.outcome == 'failure' || steps.detekt.outcome == 'failure' || steps.unit.outcome == 'failure' || steps.instr.outcome == 'failure'
        run: |
          echo "One or more checks failed."
          exit 1